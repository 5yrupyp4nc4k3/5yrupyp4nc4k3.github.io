<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Survival Squares</title>
<style>
body, html { margin:0; padding:0; overflow:hidden; background:black; font-family:monospace; color:white; }
canvas { display:block; background:black; }
#leaderboard { position:absolute; top:10px; right:10px; background: rgba(0,0,0,0.35); padding:10px; border-radius:8px; pointer-events:none; }
.overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
.overlay.show { display:flex; }
.panel { background:#111; border:1px solid #333; padding:16px; border-radius:10px; text-align:center; min-width:300px; }
.vstack { display:flex; flex-direction:column; gap:10px; align-items:center; }
.btn { padding:10px 16px; border-radius:8px; background:#111; color:#fff; border:1px solid #222; cursor:pointer; min-width:220px; }
.btn:hover { background:#1f2937; }
input[type=text] { padding:8px; border-radius:6px; border:1px solid #333; background:#050505; color:#fff; width:220px; }
.muted { color:#aaa; font-size:13px; min-height:40px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="leaderboard"></div>

<div id="startOverlay" class="overlay show">
  <div class="panel vstack">
    <h1>Survival Squares</h1>
    <input id="nameInput" type="text" placeholder="Enter your name" maxlength="16" oninput="this.value=this.value.replace(/[^a-zA-Z0-9 ]/g,'');">
    <button id="btnRespawn" class="btn" data-desc="Respawn Mode: you respawn when you die.">Respawn Mode</button>
    <button id="btnElim" class="btn" data-desc="Elimination Mode: one life. Last alive wins.">Elimination Mode</button>
    <div id="modeDesc" class="muted">Hover over a mode to see details.</div>
  </div>
</div>

<div id="pauseOverlay" class="overlay">
  <div class="panel vstack">
    <h2>Paused</h2>
    <button id="btnResume" class="btn">Resume</button>
    <button id="btnExitPause" class="btn">Exit to Menu</button>
  </div>
</div>

<div id="deathOverlay" class="overlay">
  <div class="panel vstack">
    <h2>You Died</h2>
    <div class="muted">Spectating: <span id="spectName">—</span></div>
    <button id="btnRespawnNow" class="btn">Respawn</button>
    <button id="btnExitDeath" class="btn">Exit to Menu</button>
  </div>
</div>

<div id="victoryOverlay" class="overlay">
  <div class="panel vstack">
    <h2>Victory!</h2>
    <div class="muted">You are the last one alive.</div>
    <button id="btnExitVictory" class="btn">Exit to Menu</button>
  </div>
</div>

<script>
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; } 
window.addEventListener('resize',resize); resize();

let mouseX=0, mouseY=0, mouseDown=false;
canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouseX=e.clientX-r.left; mouseY=e.clientY-r.top; });
canvas.addEventListener('mousedown', ()=>mouseDown=true);
canvas.addEventListener('mouseup', ()=>mouseDown=false);

const keys={};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Variables as per your request
const WORLD_W = 5000, WORLD_H = 5000;
const FRICTION =0.95,PLAYER_ACCEL = 1.5,AI_ACCEL = 1.5;
const MAX_SPEED_PLAYER = 13, MAX_SPEED_AI = 10;
const NUM_HUNTERS = 12, NUM_SURVIVORS = 12;
const AI_VISION = 600, SPAWN_SAFE = 700;
const PROJ_SPEED = 14,PROJ_LIFE = 120;
const SHOOT_COOLDOWN_FRAMES = Math.round(0.2*60);
const KILL_POINTS = 500;

const startOverlay=document.getElementById('startOverlay');
const pauseOverlay=document.getElementById('pauseOverlay');
const deathOverlay=document.getElementById('deathOverlay');
const victoryOverlay=document.getElementById('victoryOverlay');
const modeDesc=document.getElementById('modeDesc');
const leaderEl=document.getElementById('leaderboard');
const spectNameEl=document.getElementById('spectName');

document.querySelectorAll('#btnRespawn,#btnElim').forEach(b=>{
  b.addEventListener('mouseenter',()=>modeDesc.textContent=b.dataset.desc);
  b.addEventListener('mouseleave',()=>modeDesc.textContent='Hover over a mode to see details.');
});

let entities=[], projectiles=[], me=null, running=false, paused=false, mode='respawn';
let camX=0, camY=0, spectating=null;
const lastKiller = new Map();
let _idCounter=0; function nextId(){ return ++_idCounter; }

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function normalize(x,y){ const m=Math.hypot(x,y)||1; return [x/m, y/m]; }

class Entity {
  constructor(name,x,y,color,aiType=null){
    this.id=nextId(); this.name=name; this.x=x; this.y=y; this.vx=0; this.vy=0;
    this.size=30; this.color=color; this.aiType=aiType; this.alive=true; this.score=0;
    this.cooldown=0; this.reactionTimer=0; this._respawnTimer=null;
  }
  resetPhysics(){ this.vx=0; this.vy=0; this.cooldown=0; this.reactionTimer=0; }
  resetScore(){ this.score=0; }
  update(){
    if(!this.alive) return;
    if(this.cooldown>0) this.cooldown--;
    if(this.aiType){
      this.reactionTimer--;
      if(this.reactionTimer<=0){
        let target=entities.filter(p=>p!==this && p.alive);
        if(target.length){target=target[Math.floor(Math.random()*target.length)];
          let dx=target.x-this.x, dy=target.y-this.y;
          if(this.aiType==='hunter'){ this.vx += (dx/dist(this,target))*AI_ACCEL; this.vy += (dy/dist(this,target))*AI_ACCEL; }
          else{ this.vx -= (dx/dist(this,target))*AI_ACCEL; this.vy -= (dy/dist(this,target))*AI_ACCEL; }
          if(dist(this,target)<AI_VISION && this.cooldown<=0){ this.shootAt(target.x+target.size/2,target.y+target.size/2); }
        }
        this.reactionTimer=3;
      }
      this.vx *= FRICTION; this.vy *= FRICTION;
      const sp = Math.hypot(this.vx,this.vy);
      if(sp>MAX_SPEED_AI){ this.vx=this.vx/sp*MAX_SPEED_AI; this.vy=this.vy/sp*MAX_SPEED_AI; }
      this.x += this.vx; this.y += this.vy;
    } else {
      let ax=0, ay=0;
      if(keys['w']||keys['arrowup']) ay-=1;
      if(keys['s']||keys['arrowdown']) ay+=1;
      if(keys['a']||keys['arrowleft']) ax-=1;
      if(keys['d']||keys['arrowright']) ax+=1;
      if(ax||ay){ [ax,ay]=normalize(ax,ay); ax*=PLAYER_ACCEL; ay*=PLAYER_ACCEL; }
      this.vx += ax; this.vy += ay;
      this.vx *= FRICTION; this.vy *= FRICTION;
      const sp = Math.hypot(this.vx,this.vy);
      if(sp>MAX_SPEED_PLAYER){ this.vx=this.vx/sp*MAX_SPEED_PLAYER; this.vy=this.vy/sp*MAX_SPEED_PLAYER; }
      this.x += this.vx; this.y += this.vy;
      if(mouseDown && this.cooldown<=0){ this.shootAt(camX+mouseX, camY+mouseY); }
    }
    // Border collision
    if(this.x<0){ this.x=0; this.vx*=-1.2; } 
    if(this.y<0){ this.y=0; this.vy*=-1.2; }
    if(this.x+this.size>WORLD_W){ this.x=WORLD_W-this.size; this.vx*=-1.2; } 
    if(this.y+this.size>WORLD_H){ this.y=WORLD_H-this.size; this.vy*=-1.2; }
  }
  shootAt(tx,ty){
    if(!this.alive || this.cooldown>0) return;
    const ox=this.x+this.size/2, oy=this.y+this.size/2;
    const dx=tx-ox, dy=ty-oy; const [nx,ny]=normalize(dx,dy);
    projectiles.push(new Projectile(this,ox,oy,nx*PROJ_SPEED,ny*PROJ_SPEED));
    this.cooldown = SHOOT_COOLDOWN_FRAMES;
  }
  draw(){
    if(!this.alive) return;
    const sx=this.x-camX, sy=this.y-camY;
    ctx.fillStyle=this.color; ctx.fillRect(sx,sy,this.size,this.size);
    ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.textAlign='center';
    ctx.fillText(this.name, sx+this.size/2, sy-8);
  }
}

class Projectile{
  constructor(owner,x,y,vx,vy){ this.owner=owner; this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.size=6; this.life=PROJ_LIFE; this.color=owner.color; }
  update(){
    this.x+=this.vx; this.y+=this.vy; this.life--;
    if(this.x<0){ this.x=0; this.vx*=-1; } 
    if(this.y<0){ this.y=0; this.vy*=-1; }
    if(this.x>WORLD_W){ this.x=WORLD_W; this.vx*=-1; } 
    if(this.y>WORLD_H){ this.y=WORLD_H; this.vy*=-1; }
    entities.forEach(e=>{
      if(e.alive && e!==this.owner && Math.abs(e.x+e.size/2-this.x)<e.size/2 && Math.abs(e.y+e.size/2-this.y)<e.size/2){
        e.alive=false; this.owner.score += KILL_POINTS; this.life=0;
        lastKiller.set(e,this.owner);
        if(e===me){ if(mode==='respawn') showDeath(this.owner); else if(mode==='elim'){showDeath(this.owner);} }
        if(mode==='elim' && entities.filter(x=>x.alive).length===1 && me.alive) showVictory();
      }
    });
  }
  draw(){ ctx.fillStyle=this.color; ctx.fillRect(this.x-camX-this.size/2,this.y-camY-this.size/2,this.size,this.size); }
}

// Spawning, respawn, overlays, loop, etc. same as before
// When respawning, reset score for everyone
function findSafeSpawn(){
  for(let i=0;i<1000;i++){
    const x=rand(SPAWN_SAFE,WORLD_W-SPAWN_SAFE), y=rand(SPAWN_SAFE,WORLD_H-SPAWN_SAFE);
    if(entities.every(p=>Math.hypot(p.x-x,p.y-y)>SPAWN_SAFE)) return {x,y};
  }
  return {x:WORLD_W/2+rand(-200,200), y:WORLD_H/2+rand(-200,200)};
}

function spawnMatch(playerName){
  entities=[]; projectiles=[]; lastKiller.clear(); spectating=null;
  me=null;
  const start=findSafeSpawn();
  me=new Entity(playerName||'Player',start.x,start.y,'cyan'); me.resetPhysics(); me.resetScore(); entities.push(me);
  for(let i=0;i<NUM_HUNTERS;i++){ const s=findSafeSpawn(); let e=new Entity('Hunter'+i,s.x,s.y,'red','hunter'); e.resetScore(); entities.push(e); }
  for(let i=0;i<NUM_SURVIVORS;i++){ const s=findSafeSpawn(); let e=new Entity('Survivor'+i,s.x,s.y,'lime','survivor'); e.resetScore(); entities.push(e); }
  hideAllOverlays(); running=true; paused=false; requestAnimationFrame(loop);
}

function respawnPlayer(){ spawnMatch(document.getElementById('nameInput').value||'Player'); }
function pickAnyAlive(){ return entities.find(e=>e.alive); }
function hideAllOverlays(){ [startOverlay,pauseOverlay,deathOverlay,victoryOverlay].forEach(el=>el.classList.remove('show')); }
function showDeath(killer){ hideAllOverlays(); deathOverlay.classList.add('show'); spectating=killer||pickAnyAlive(); updateSpectName(); running=false; }
function showVictory(){ hideAllOverlays(); victoryOverlay.classList.add('show'); running=false; }
function updateSpectName(){ spectNameEl.textContent = spectating ? spectating.name : '—'; }
function exitToMenu(){ entities=[];projectiles=[]; lastKiller.clear(); me=null; spectating=null; leaderEl.innerHTML=''; running=false; paused=false; hideAllOverlays(); startOverlay.classList.add('show'); }

document.getElementById('btnRespawn').addEventListener('click',()=>{ mode='respawn'; spawnMatch(document.getElementById('nameInput').value||'Player'); });
document.getElementById('btnElim').addEventListener('click',()=>{ mode='elim'; spawnMatch(document.getElementById('nameInput').value||'Player'); });
document.getElementById('btnResume').addEventListener('click',()=>{ paused=false; hideAllOverlays(); running=true; requestAnimationFrame(loop); });
document.getElementById('btnExitPause').addEventListener('click', exitToMenu);
document.getElementById('btnRespawnNow').addEventListener('click',()=>{ if(mode==='respawn') respawnPlayer(); });
document.getElementById('btnExitDeath').addEventListener('click', exitToMenu);
document.getElementById('btnExitVictory').addEventListener('click', exitToMenu);

function drawGrid(){
    ctx.fillStyle='#111'; ctx.fillRect(-camX,-camY,canvas.width,canvas.height);
    ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(-camX,-camY,WORLD_W,WORLD_H);
    ctx.strokeStyle='#222'; ctx.lineWidth=1;
    for(let x=0;x<=WORLD_W;x+=50){ ctx.beginPath(); ctx.moveTo(x-camX,0-camY); ctx.lineTo(x-camX,WORLD_H-camY); ctx.stroke(); }
    for(let y=0;y<=WORLD_H;y+=50){ ctx.beginPath(); ctx.moveTo(0-camX,y-camY); ctx.lineTo(WORLD_W-camX,y-camY); ctx.stroke(); }
}

function updateLeaderboard(){
    let board=entities.filter(e=>e.alive).sort((a,b)=>b.score-a.score).slice(0,10);
    leaderEl.innerHTML='<b>Leaderboard</b><br>'+board.map((p,i)=>`${i+1}. ${p.name}: ${p.score}`).join('<br>');
}

function loop(){
  if(!running) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(me && me.alive){ camX=me.x-canvas.width/2; camY=me.y-canvas.height/2; }
  drawGrid();
  entities.forEach(e=>e.update());
  projectiles.forEach(p=>p.update());
  projectiles=projectiles.filter(p=>p.life>0);

  // collisions: entity vs entity
  for(let a of entities){if(!a.alive)continue; for(let b of entities){if(a===b||!b.alive)continue;
    if(Math.abs(a.x-b.x)<a.size && Math.abs(a.y-b.y)<a.size){
      a.alive=false;b.alive=false;a.resetScore();b.resetScore();
      lastKiller.set(a,b);lastKiller.set(b,a);
      if(a===me||b===me) showDeath(a===me?b:a); 
      if(mode==='elim' && entities.filter(x=>x.alive).length===1 && me.alive) showVictory();
    }
  }}

  // Respawn AI
  entities.forEach(e=>{
    if(!e.alive && e.aiType && mode==='respawn'){ 
      if(!e._respawnTimer) e._respawnTimer=180; 
      e._respawnTimer--; 
      if(e._respawnTimer<=0){
        const s=findSafeSpawn(); e.x=s.x; e.y=s.y; e.alive=true; e.resetPhysics(); e.resetScore(); e._respawnTimer=null;
      }
    }
  });

  entities.forEach(e=>e.draw());
  projectiles.forEach(p=>p.draw());
  updateLeaderboard();
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
